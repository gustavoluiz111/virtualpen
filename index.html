<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caneta Virtual AI (Mobile)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe Hands CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675469240/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675469240/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        /* Define a fonte Inter e o layout para telas pequenas */
        body { font-family: 'Inter', sans-serif; }
        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* Propor√ß√£o 4:3 (75% da largura) */
        }
        canvas, video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        /* O canvas de desenho deve ser transparente */
        #drawingCanvas {
            background-color: transparent;
            z-index: 10;
        }
        /* O canvas de v√≠deo precisa estar atr√°s */
        #outputCanvas {
            z-index: 5;
            transform: scaleX(-1); /* Espelha o v√≠deo */
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center p-2 sm:p-4">
    <h1 class="text-2xl font-bold mb-4 text-indigo-400">Caneta Virtual Web (Gestos)</h1>
    
    <!-- Controles de Cor e A√ß√£o -->
    <div id="controls" class="flex flex-wrap justify-center gap-2 p-2 bg-gray-800 rounded-xl shadow-lg w-full max-w-lg mb-4">
        <button onclick="changeColor('255, 0, 0', 'Desenhar')" class="color-btn bg-red-600 hover:bg-red-700 active:ring-4 active:ring-red-400">Vermelho</button>
        <button onclick="changeColor('0, 255, 0', 'Desenhar')" class="color-btn bg-green-600 hover:bg-green-700 active:ring-4 active:ring-green-400">Verde</button>
        <button onclick="changeColor('0, 0, 255', 'Desenhar')" class="color-btn bg-blue-600 hover:bg-blue-700 active:ring-4 active:ring-blue-400">Azul</button>
        <button onclick="changeColor('0, 0, 0', 'Apagar')" class="color-btn bg-gray-500 hover:bg-gray-600 active:ring-4 active:ring-gray-300">Borracha</button>
        <button onclick="clearCanvas()" class="color-btn bg-indigo-600 hover:bg-indigo-700 active:ring-4 active:ring-indigo-400">Limpar</button>
    </div>

    <!-- Container do V√≠deo e Canvas de Desenho -->
    <div class="canvas-container w-full max-w-xl rounded-xl overflow-hidden shadow-2xl border-4 border-indigo-500">
        <!-- O canvas de sa√≠da do MediaPipe (v√≠deo espelhado e landmarks) -->
        <canvas id="outputCanvas"></canvas>
        <!-- O canvas onde desenhamos -->
        <canvas id="drawingCanvas"></canvas>
    </div>

    <!-- Feedback e Status -->
    <div id="status" class="mt-4 p-3 bg-gray-800 rounded-lg w-full max-w-xl text-center text-sm font-semibold">
        <p>Modo: <span id="currentMode" class="text-green-400">INATIVO (Aguardando C√¢mera)</span></p>
        <p>A√ß√µes: üëÜ Desenhar, ü§û Borracha, ‚úä Limpar Tela (Gesto).</p>
    </div>
    
    <script>
        // Configura√ß√µes Globais
        const DRAW_THICKNESS = 8;
        const ERASER_THICKNESS = 40;
        let drawColor = '0, 255, 0'; // Inicialmente verde
        let currentTool = 'Desenhar';
        let prevX = 0, prevY = 0;
        let canvas, ctx;
        let videoElement, camera;

        const outputCanvas = document.getElementById('outputCanvas');
        const outputCtx = outputCanvas.getContext('2d');
        const statusElement = document.getElementById('currentMode');
        
        // --- 1. Inicializa√ß√£o do Canvas de Desenho ---
        function initDrawingCanvas() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');

            // Ajusta o canvas de desenho para o mesmo tamanho do output canvas (MediaPipe)
            const videoWidth = outputCanvas.width;
            const videoHeight = outputCanvas.height;
            canvas.width = videoWidth;
            canvas.height = videoHeight;
        }

        // --- 2. L√≥gica de Gestos ---
        function getDrawingMode(landmarks) {
            if (!landmarks || landmarks.length === 0) return 'IDLE';

            // Normaliza a posi√ß√£o da m√£o para evitar detec√ß√£o quando a m√£o est√° muito longe
            const wristY = landmarks[0].y;
            const thumbTipX = landmarks[4].x;

            // √çndices dos pontos de interesse
            const fingerTips = [8, 12, 16, 20]; // Indicador, M√©dio, Anelar, M√≠nimo
            const pips = [6, 10, 14, 18];        // Articula√ß√µes centrais
            const fingersUp = [];

            // Checa quais dedos est√£o levantados
            for (let i = 0; i < fingerTips.length; i++) {
                // A ponta est√° 'acima' (menor valor Y) do pip
                const isUp = landmarks[fingerTips[i]].y < landmarks[pips[i]].y;
                fingersUp.push(isUp);
            }

            // 0=Indicador, 1=M√©dio, 2=Anelar, 3=M√≠nimo
            const allDown = !fingersUp.some(up => up); 

            // Sinal 1: LIMPAR TELA (Punho Fechado)
            if (allDown) {
                return 'CLEAR';
            }

            // Sinal 2: BORRACHA (Indicador e M√©dio levantados) - ü§û
            if (fingersUp[0] && fingersUp[1] && !fingersUp[2] && !fingersUp[3]) {
                return 'ERASE';
            }
            
            // Sinal 3: DESENHAR (Apenas o Indicador levantado) - üëÜ
            if (fingersUp[0] && !fingersUp[1] && !fingersUp[2] && !fingersUp[3]) {
                return 'DRAW';
            }
            
            // Sinal 4: IDLE (Pausa/Outro Gesto)
            return 'IDLE';
        }


        // --- 3. Desenho e Loop de Renderiza√ß√£o ---
        function onResults(results) {
            outputCtx.save();
            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            // Desenha o v√≠deo, espelhado para dar o efeito de espelho
            outputCtx.scale(-1, 1);
            outputCtx.translate(-outputCanvas.width, 0);
            outputCtx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);
            outputCtx.restore();

            let mode = 'IDLE';
            let currentX = 0;
            let currentY = 0;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Desenha os landmarks (pontos e conex√µes)
                drawConnectors(outputCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
                drawLandmarks(outputCtx, landmarks, { color: '#FF0000', lineWidth: 1 });

                mode = getDrawingMode(landmarks);

                // Obt√©m a posi√ß√£o da ponta do indicador (Landmark 8)
                const indexTip = landmarks[8];
                currentX = (1 - indexTip.x) * outputCanvas.width; // 1 - x para compensar o espelhamento
                currentY = indexTip.y * outputCanvas.height;
            }

            // --- L√≥gica de A√ß√£o ---
            
            if (mode === 'CLEAR') {
                clearCanvas();
                statusElement.textContent = 'LIMPOU TELA (Punho Fechado)!';
                statusElement.classList.remove('text-red-400');
                statusElement.classList.add('text-yellow-400');
                prevX = 0; prevY = 0;
                return;
            }

            if (mode === 'DRAW' || mode === 'ERASE') {
                
                const thickness = mode === 'DRAW' ? DRAW_THICKNESS : ERASER_THICKNESS;
                const color = mode === 'DRAW' ? `rgb(${drawColor})` : 'rgb(0, 0, 0)'; // Borracha √© preto
                const globalCompositeOperation = mode === 'DRAW' ? 'source-over' : 'destination-out'; // Borracha

                statusElement.textContent = mode === 'DRAW' ? `DESENHANDO (${currentTool})` : 'APAGANDO (Borracha)';
                statusElement.classList.remove('text-yellow-400');
                statusElement.classList.add(mode === 'DRAW' ? 'text-green-400' : 'text-red-400');
                
                if (prevX === 0 && prevY === 0) {
                    // Come√ßa um novo tra√ßo, movendo para a posi√ß√£o atual
                    prevX = currentX;
                    prevY = currentY;
                } else {
                    // Desenha o tra√ßo
                    ctx.beginPath();
                    ctx.globalCompositeOperation = globalCompositeOperation;
                    ctx.moveTo(prevX, prevY);
                    ctx.lineTo(currentX, currentY);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = thickness;
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    // Atualiza a posi√ß√£o
                    prevX = currentX;
                    prevY = currentY;
                }

            } else {
                // Modo IDLE (Inativo ou Gesto de Sele√ß√£o de Cor/IDLE)
                statusElement.textContent = 'INATIVO (Aguardando Gesto)';
                statusElement.classList.remove('text-red-400', 'text-green-400', 'text-yellow-400');
                statusElement.classList.add('text-white');
                prevX = 0; prevY = 0; // Reseta o cursor para evitar tra√ßos acidentais
            }
        }

        // --- 4. Fun√ß√µes de Controle ---
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function changeColor(colorRgb, toolName) {
            drawColor = colorRgb;
            currentTool = toolName;
            
            // Remove o destaque dos bot√µes
            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('ring-4', 'ring-offset-2', 'ring-indigo-400'));
            
            // Adiciona destaque ao bot√£o clicado
            const clickedBtn = event.target;
            clickedBtn.classList.add('ring-4', 'ring-offset-2', 'ring-indigo-400');
            
            // Atualiza o feedback visual
            statusElement.textContent = `Cor alterada para ${toolName}!`;
        }

        // --- 5. Inicializa√ß√£o da C√¢mera ---
        const hands = new Hands({locateFile: (file) => {
            // Caminho para os arquivos do MediaPipe
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1, // 0 para Mobile, 1 para Padr√£o (performance)
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // O Camera API lida com a captura de v√≠deo e envio para o MediaPipe
        videoElement = document.createElement('video');
        
        const outputCanvasContainer = document.querySelector('.canvas-container');
        
        camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: outputCanvasContainer.offsetWidth,
            height: outputCanvasContainer.offsetHeight * 0.75 // Mant√©m a propor√ß√£o 4:3
        });

        // Garantir que os canvas tenham o tamanho correto ap√≥s a inicializa√ß√£o da c√¢mera
        videoElement.addEventListener('loadedmetadata', () => {
            // Define o tamanho de ambos os canvas com base no v√≠deo (320x240 √© um bom ponto de partida)
            outputCanvas.width = 320;
            outputCanvas.height = 240;
            initDrawingCanvas();
            camera.start();
        });
        
        // --- Inicia ---
        camera.start();
        initDrawingCanvas();
    </script>
</body>
</html>


