<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Caneta Virtual Gestos ‚Äî Completo</title>

<!-- Tailwind opcional -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- MediaPipe Hands + utilit√°rios -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675469240/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675469240/camera_utils.js"></script>

<style>
  body { background:#0f1724; color:#e6eef8; font-family:Inter, system-ui, Arial; display:flex; flex-direction:column; align-items:center; gap:12px; padding:18px; }
  .card { width:100%; max-width:820px; }
  .canvas-wrap { position:relative; width:100%; padding-top:60%; background:#0b1220; border-radius:14px; overflow:hidden; border:3px solid rgba(99,102,241,0.25); }
  canvas, video { position:absolute; top:0; left:0; width:100%; height:100%; display:block; }
  #videoEl { display:none; } /* usamos o canvas para exibir v√≠deo */
  #controls { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-top:8px; }
  .btn { padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }
  .legend { font-size:0.92rem; background:rgba(255,255,255,0.03); padding:10px; border-radius:8px; margin-top:10px; }
  .status { font-weight:700; text-align:center; padding:8px 10px; border-radius:8px; background:rgba(255,255,255,0.02); }
</style>
</head>
<body>

<div class="card">
  <h1 style="text-align:center; color:#7c3aed; font-size:1.25rem; margin-bottom:6px;">Caneta Virtual Gestos</h1>

  <div style="display:flex; gap:10px; justify-content:center; margin-bottom:8px;">
    <button id="startBtn" class="btn" style="background:#7c3aed; color:white;">‚ñ∂Ô∏è Iniciar C√¢mera</button>
    <button id="downloadBtn" class="btn" style="background:#f59e0b; color:#08111c;">Salvar PNG</button>
    <button id="clearBtn" class="btn" style="background:#374151; color:white;">Limpar</button>
  </div>

  <div class="canvas-wrap">
    <!-- canvas que mostra o stream (espelhado) -->
    <canvas id="videoCanvas"></canvas>
    <!-- canvas de desenho (posi√ß√£o na frente) -->
    <canvas id="drawCanvas"></canvas>
    <!-- v√≠deo oculto (fonte para MediaPipe) -->
    <video id="videoEl" playsinline></video>
  </div>

  <div id="controls" style="margin-top:10px;">
    <div id="colorRed" class="btn" style="background:#ef4444;color:white;">Vermelho</div>
    <div id="colorGreen" class="btn" style="background:#10b981;color:white;">Verde</div>
    <div id="colorBlue" class="btn" style="background:#3b82f6;color:white;">Azul</div>
    <div id="eraserBtn" class="btn" style="background:#9ca3af;color:#08111c;">Borracha</div>
  </div>

  <div id="status" class="status" style="margin-top:10px;">Modo: <span id="modeText">INATIVO</span></div>

  <div class="legend" style="margin-top:12px;">
    <strong>Legenda (gestos):</strong>
    <ul style="margin:6px 0 0 18px;">
      <li>üëÜ Indicador levantado sozinho ‚Üí DESENHAR</li>
      <li>ü§û Indicador + m√©dio levantados ‚Üí BORRACHA (apagar)</li>
      <li>‚úä Punho fechado (todos dedos baixos) ‚Üí LIMPAR TELA</li>
      <li>Mover o dedo indicador para o topo: esquerda/centro/direita troca cor para Vermelho/Verde/Azul</li>
      <li>Tamb√©m √© poss√≠vel trocar cor pelos bot√µes abaixo do canvas</li>
    </ul>
  </div>
</div>

<script>
/* ==========================
   Configura√ß√µes e helpers
   ========================== */
const VIDEO_W = 640;
const VIDEO_H = 480;

const videoEl = document.getElementById('videoEl');
const videoCanvas = document.getElementById('videoCanvas');
const drawCanvas = document.getElementById('drawCanvas');
const vctx = videoCanvas.getContext('2d', { willReadFrequently:true });
const dctx = drawCanvas.getContext('2d');

videoCanvas.width = drawCanvas.width = VIDEO_W;
videoCanvas.height = drawCanvas.height = VIDEO_H;

let drawColor = 'rgb(239,68,68)'; // vermelho inicial
let isEraser = false;
let prev = null; // {x,y}
let smoothing = { x:0, y:0, smoothFactor:0.6 }; // simples suaviza√ß√£o
let lastSeen = Date.now();
let handsAvailable = false;

/* Ajustar tamanho dos canvases conforme container (mantendo propor√ß√£o) */
function resizeToContainer(){
  const wrap = document.querySelector('.canvas-wrap');
  const rect = wrap.getBoundingClientRect();
  videoCanvas.style.width = drawCanvas.style.width = rect.width + 'px';
  videoCanvas.style.height = drawCanvas.style.height = rect.height + 'px';
}
window.addEventListener('resize', resizeToContainer);
resizeToContainer();

/* Util: mapear landmark.x (0..1) para coordenada no canvas j√° espelhada */
function landmarkToCoords(landmark){
  // landmark.x: 0 = esquerda da imagem original (n√£o espelhada)
  // Como vamos desenhar o v√≠deo espelhado para comportamento "frontal",
  // a posi√ß√£o visual do dedo no canvas espelhado √©:
  const x = (1 - landmark.x) * VIDEO_W;
  const y = landmark.y * VIDEO_H;
  return { x, y };
}

/* ==========================
   Fun√ß√µes de desenho
   ========================== */
function clearDrawing(){
  dctx.clearRect(0,0,drawCanvas.width, drawCanvas.height);
  prev = null;
}

function drawLine(x1,y1,x2,y2, color, thickness, composite='source-over'){
  dctx.save();
  dctx.globalCompositeOperation = composite;
  dctx.beginPath();
  dctx.moveTo(x1,y1);
  dctx.lineTo(x2,y2);
  dctx.strokeStyle = color;
  dctx.lineWidth = thickness;
  dctx.lineCap = 'round';
  dctx.stroke();
  dctx.restore();
}

/* ==========================
   UI e controles
   ========================== */
document.getElementById('startBtn').addEventListener('click', startCamera);
document.getElementById('clearBtn').addEventListener('click', () => { clearDrawing(); setModeText('LIMPOU'); });
document.getElementById('downloadBtn').addEventListener('click', () => {
  // mesclar video (transparente) + desenho para salvar s√≥ o desenho
  const link = document.createElement('a');
  link.download = 'caneta_virtual.png';
  link.href = drawCanvas.toDataURL('image/png');
  link.click();
});
document.getElementById('colorRed').addEventListener('click', ()=>{ drawColor='rgb(239,68,68)'; isEraser=false; setModeText('Vermelho'); });
document.getElementById('colorGreen').addEventListener('click', ()=>{ drawColor='rgb(16,185,129)'; isEraser=false; setModeText('Verde'); });
document.getElementById('colorBlue').addEventListener('click', ()=>{ drawColor='rgb(59,130,246)'; isEraser=false; setModeText('Azul'); });
document.getElementById('eraserBtn').addEventListener('click', ()=>{ isEraser=true; setModeText('Borracha'); });

function setModeText(t){ document.getElementById('modeText').textContent = t; }

/* ==========================
   MediaPipe Hands setup
   ========================== */
const hands = new Hands({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.5
});

/* Quando o MediaPipe devolve resultados */
hands.onResults(onResults);

/* Camera util que usa o videoEl como fonte */
let cameraInstance = null;

/* Iniciar c√¢mera com seguran√ßa */
async function startCamera(){
  const startBtn = document.getElementById('startBtn');
  startBtn.disabled = true;
  startBtn.textContent = 'Solicitando c√¢mera...';

  try{
    cameraInstance = new Camera(videoEl, {
      onFrame: async () => {
        await hands.send({image: videoEl});
      },
      width: VIDEO_W,
      height: VIDEO_H,
    });
    await cameraInstance.start();
    startBtn.style.display = 'none';
    setModeText('C√¢mera Iniciada ‚Äî Aguardando gesto');
  } catch (err) {
    console.error('Erro iniciando c√¢mera:', err);
    startBtn.disabled = false;
    startBtn.textContent = '‚ñ∂Ô∏è Iniciar C√¢mera';
    // Mensagem amig√°vel explicando overlay/permit
    alert(
`N√£o foi poss√≠vel iniciar a c√¢mera.
Poss√≠veis causas:
‚Ä¢ O navegador n√£o tem permiss√£o para acessar a c√¢mera.
‚Ä¢ H√° um APP com sobreposi√ß√£o/bolhas (chat head) bloqueando a permiss√£o em Android.
Solu√ß√µes:
1) Feche apps com bolhas/overlays (ex.: Facebook Messenger, alguns boosters).
2) V√° em Configura√ß√µes do App (navegador) ‚Üí Permiss√µes ‚Üí C√¢mera ‚Üí permitir.
3) Recarregue a p√°gina e tente novamente.
Se estiver hospedado em servidor, verifique se √© HTTPS (getUserMedia exige HTTPS).`
    );
    setModeText('ERRO: permiss√£o/c√¢mera');
  }
}

/* ==========================
   onResults: desenhar v√≠deo + processar landmarks
   ========================== */
let lastProcess = 0;
const PROCESS_INTERVAL = 16; // ~60fps m√°ximo

function onResults(results){
  // 1) desenhar o v√≠deo espelhado no canvas videoCanvas
  vctx.save();
  vctx.clearRect(0,0,VIDEO_W, VIDEO_H);
  // espelhar horizontalmente (comportamento c√¢mera frontal)
  vctx.scale(-1, 1);
  vctx.drawImage(results.image, -VIDEO_W, 0, VIDEO_W, VIDEO_H);
  vctx.restore();

  // 2) desenhar landmarks sobre o v√≠deo (espelhados)
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    handsAvailable = true;
    lastSeen = Date.now();
    const lm = results.multiHandLandmarks[0];

    // desenhar conectores/landmarks espelhados:
    vctx.save();
    vctx.scale(-1, 1);
    vctx.translate(-VIDEO_W, 0);
    drawConnectors(vctx, lm, HAND_CONNECTIONS, { color: '#00FFAA', lineWidth: 2 });
    drawLandmarks(vctx, lm, { color: '#FF0066', lineWidth: 1 });
    vctx.restore();

    // controlar a√ß√£o de desenho com gestos
    handleGesturesAndDrawing(lm);
  } else {
    // sem m√£o detectada
    // se sem m√£o h√° muito tempo, reset prev para evitar linhas conectando quando reaparece
    if (Date.now() - lastSeen > 250) {
      prev = null;
      setModeText('INATIVO');
    }
    handsAvailable = false;
  }
}

/* ==========================
   L√≥gica de gestos e desenho
   ========================== */
let lastGestureCheck = 0;
const GESTURE_THROTTLE = 80; // ms

function handleGesturesAndDrawing(landmarks){
  // landmarks: array de pontos com {x,y,z}
  // 1) detectar dedos levantados (usamos 8(tip)/6(pip) etc)
  // Observa√ß√£o: landmarks s√£o relativos √† imagem n√£o espelhada; como desenhamos espelhado, mapeamos coords para canvas com landmarkToCoords()

  const tips = [8, 12, 16, 20];
  const pips = [6, 10, 14, 18];
  const up = [];
  for (let i=0;i<4;i++){
    up.push(landmarks[tips[i]].y < landmarks[pips[i]].y); // y menor -> dedo levantado para a camera (normal)
  }
  const allDown = !up.some(v=>v);
  const indexUp = up[0];
  const middleUp = up[1];

  // Gestos principais:
  // ALL DOWN -> CLEAR
  if (allDown){
    clearDrawing();
    setModeText('LIMPOU (Punho)');
    return;
  }

  // Two fingers (index + middle) => BORRACHA
  if (indexUp && middleUp && !up[2] && !up[3]) {
    isEraser = true;
    setModeText('BORRACHA (gesto)');
  } else if (indexUp && !middleUp && !up[2] && !up[3]) {
    isEraser = false;
    setModeText('DESENHANDO (gesto)');
  } else {
    // se nenhum gesto de desenho ativo, sair
    prev = null;
  }

  // Troca de cor por zonas no topo (h√° throttling)
  if (Date.now() - lastGestureCheck > GESTURE_THROTTLE) {
    lastGestureCheck = Date.now();
    // se indicador estiver alto (y pequeno) trocamos cor por zona x
    const idxTip = landmarks[8];
    const coordsPreview = landmarkToCoords(idxTip);
    if (coordsPreview.y < VIDEO_H * 0.18) {
      // dividir em 3 zonas horizontais
      if (coordsPreview.x < VIDEO_W/3) { drawColor = 'rgb(239,68,68)'; isEraser=false; setModeText('Vermelho (zona)'); }
      else if (coordsPreview.x < 2*VIDEO_W/3) { drawColor = 'rgb(16,185,129)'; isEraser=false; setModeText('Verde (zona)'); }
      else { drawColor = 'rgb(59,130,246)'; isEraser=false; setModeText('Azul (zona)'); }
    }
  }

  // Desenho: calcular coordenadas (com suaviza√ß√£o)
  const tip = landmarks[8];
  const {x: rawX, y: rawY} = landmarkToCoords(tip); // j√° mapeado para canvas espelhado
  // suaviza√ß√£o simples exponencial
  if (!smoothing.x) { smoothing.x = rawX; smoothing.y = rawY; }
  smoothing.x = smoothing.x * smoothing.smoothFactor + rawX * (1 - smoothing.smoothFactor);
  smoothing.y = smoothing.y * smoothing.smoothFactor + rawY * (1 - smoothing.smoothFactor);
  const x = smoothing.x;
  const y = smoothing.y;

  // Se estamos em modo desenho/eraser (indexUp true) desenhar linha entre prev e atual
  if (indexUp) {
    const thickness = isEraser ? 48 : 8;
    const composite = isEraser ? 'destination-out' : 'source-over';
    const color = isEraser ? 'rgba(0,0,0,1)' : drawColor;

    if (prev) {
      // desenha v√°rias pequenas linhas curtas para suavizar (evita pule)
      drawLine(prev.x, prev.y, x, y, color, thickness, composite);
    } else {
      // desenha um ponto inicial para evitar buraco
      dctx.save();
      dctx.globalCompositeOperation = composite;
      dctx.beginPath();
      dctx.fillStyle = color;
      dctx.arc(x, y, thickness/2, 0, Math.PI*2);
      dctx.fill();
      dctx.restore();
    }
    prev = {x, y};
  } else {
    prev = null;
  }
}

/* ==========================
   Redimensionamento (quando a tela muda)
   ========================== */
function adaptSizeToScreen(){
  // Manter a resolu√ß√£o de processamento (VIDEO_W x VIDEO_H), mas ajustar estilos para container
  resizeToContainer();
}
window.addEventListener('load', adaptSizeToScreen);

/* ==========================
   Observa√ß√µes de permiss√£o (ajuda para usu√°rio)
   ========================== */
/*
Se no seu tablet aparece ‚ÄúEste site n√£o pode pedir permiss√µes‚Äù:
  ‚Ä¢ Feche apps com sobreposi√ß√£o (bolhas/chat heads).
  ‚Ä¢ V√° em Configura√ß√µes ‚Üí Apps ‚Üí (seu navegador) ‚Üí Permiss√µes ‚Üí C√¢mera ‚Üí permitir.
  ‚Ä¢ Recarregue a p√°gina e clique em Iniciar.
  ‚Ä¢ Certifique-se de usar um navegador atualizado (Chrome/Edge) e que a URL esteja em HTTPS.
*/

/* ==========================
   Final
   ========================== */
</script>
</body>
</html>
