<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caneta Virtual AI (Mobile)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675469240/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675469240/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        /* Define a fonte Inter e o layout para telas pequenas */
        body { font-family: 'Inter', sans-serif; }
        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* Propor√ß√£o 4:3 (75% da largura) */
        }
        canvas, video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        /* O canvas de desenho deve ser transparente */
        #drawingCanvas {
            background-color: transparent;
            z-index: 10;
        }
        /* O canvas de v√≠deo precisa estar atr√°s */
        #outputCanvas {
            z-index: 5;
            transform: scaleX(-1); /* Espelha o v√≠deo */
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center p-2 sm:p-4">
    <h1 class="text-2xl font-bold mb-4 text-indigo-400">Caneta Virtual Web (Gestos)</h1>
    
    <button id="start-btn" onclick="startVirtualPen()" 
            class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-full shadow-lg transition duration-300 transform hover:scale-105 mb-4">
        ‚ñ∂Ô∏è Iniciar C√¢mera
    </button>

    <div id="controls" class="flex flex-wrap justify-center gap-2 p-2 bg-gray-800 rounded-xl shadow-lg w-full max-w-lg mb-4">
        <button onclick="changeColor('255, 0, 0', 'Desenhar', event)" class="color-btn bg-red-600 hover:bg-red-700 active:ring-4 active:ring-red-400 ring-4 ring-offset-2 ring-indigo-400 ring-offset-gray-900">Vermelho</button>
        <button onclick="changeColor('0, 255, 0', 'Desenhar', event)" class="color-btn bg-green-600 hover:bg-green-700 active:ring-4 active:ring-green-400">Verde</button>
        <button onclick="changeColor('0, 0, 255', 'Desenhar', event)" class="color-btn bg-blue-600 hover:bg-blue-700 active:ring-4 active:ring-blue-400">Azul</button>
        <button onclick="changeColor('0, 0, 0', 'Apagar', event)" class="color-btn bg-gray-500 hover:bg-gray-600 active:ring-4 active:ring-gray-300">Borracha</button>
        <button onclick="clearCanvas()" class="color-btn bg-indigo-600 hover:bg-indigo-700 active:ring-4 active:ring-indigo-400">Limpar</button>
    </div>

    <div class="canvas-container w-full max-w-xl rounded-xl overflow-hidden shadow-2xl border-4 border-indigo-500">
        <canvas id="outputCanvas"></canvas>
        <canvas id="drawingCanvas"></canvas>
    </div>

    <div id="status" class="mt-4 p-3 bg-gray-800 rounded-lg w-full max-w-xl text-center text-sm font-semibold">
        <p>Modo: <span id="currentMode" class="text-white">INATIVO (Clique em Iniciar C√¢mera)</span></p>
        <p>A√ß√µes: üëÜ Desenhar, ü§û Borracha, ‚úä Limpar Tela (Gesto).</p>
    </div>
    
    <script>
        // --- 1. Configura√ß√µes Globais ---
        const DRAW_THICKNESS = 8;
        const ERASER_THICKNESS = 40;
        let drawColor = '255, 0, 0'; // Inicialmente Vermelho
        let currentTool = 'Desenhar';
        let prevX = 0, prevY = 0;
        let canvas, ctx;
        let videoElement;
        let camera; // Vari√°vel para a inst√¢ncia da c√¢mera
        
        const outputCanvas = document.getElementById('outputCanvas');
        const outputCtx = outputCanvas.getContext('2d');
        const statusElement = document.getElementById('currentMode');
        
        // --- 2. Inicializa√ß√£o do Canvas de Desenho ---
        function initDrawingCanvas() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');

            // Ajusta o canvas de desenho para o mesmo tamanho do output canvas (MediaPipe)
            const videoWidth = outputCanvas.width;
            const videoHeight = outputCanvas.height;
            canvas.width = videoWidth;
            canvas.height = videoHeight;
        }

        // --- 3. L√≥gica de Gestos ---
        function getDrawingMode(landmarks) {
            if (!landmarks || landmarks.length === 0) return 'IDLE';

            // √çndices dos pontos de interesse
            const fingerTips = [8, 12, 16, 20]; // Indicador, M√©dio, Anelar, M√≠nimo
            const pips = [6, 10, 14, 18];        // Articula√ß√µes centrais
            const fingersUp = [];

            // Checa quais dedos est√£o levantados
            for (let i = 0; i < fingerTips.length; i++) {
                // A ponta est√° 'acima' (menor valor Y) do pip
                const isUp = landmarks[fingerTips[i]].y < landmarks[pips[i]].y;
                fingersUp.push(isUp);
            }

            // 0=Indicador, 1=M√©dio, 2=Anelar, 3=M√≠nimo
            const allDown = !fingersUp.some(up => up); 

            // Sinal 1: LIMPAR TELA (Punho Fechado) - ‚úä
            if (allDown) {
                return 'CLEAR';
            }

            // Sinal 2: BORRACHA (Indicador e M√©dio levantados) - ü§û
            if (fingersUp[0] && fingersUp[1] && !fingersUp[2] && !fingersUp[3]) {
                return 'ERASE';
            }
            
            // Sinal 3: DESENHAR (Apenas o Indicador levantado) - üëÜ
            if (fingersUp[0] && !fingersUp[1] && !fingersUp[2] && !fingersUp[3]) {
                return 'DRAW';
            }
            
            // Sinal 4: IDLE (Pausa/Outro Gesto)
            return 'IDLE';
        }


        // --- 4. Desenho e Loop de Renderiza√ß√£o (onResults) ---
        function onResults(results) {
            outputCtx.save();
            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            // Desenha o v√≠deo, espelhado para dar o efeito de espelho
            outputCtx.scale(-1, 1);
            outputCtx.translate(-outputCanvas.width, 0);
            outputCtx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);
            outputCtx.restore();

            let mode = 'IDLE';
            let currentX = 0;
            let currentY = 0;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Desenha os landmarks (pontos e conex√µes)
                drawConnectors(outputCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
                drawLandmarks(outputCtx, landmarks, { color: '#FF0000', lineWidth: 1 });

                mode = getDrawingMode(landmarks);

                // Obt√©m a posi√ß√£o da ponta do indicador (Landmark 8)
                const indexTip = landmarks[8];
                currentX = (1 - indexTip.x) * outputCanvas.width; // 1 - x para compensar o espelhamento
                currentY = indexTip.y * outputCanvas.height;
            }

            // --- L√≥gica de A√ß√£o ---
            
            if (mode === 'CLEAR') {
                clearCanvas();
                statusElement.textContent = 'LIMPOU TELA (Punho Fechado)!';
                statusElement.classList.remove('text-red-400', 'text-green-400', 'text-white');
                statusElement.classList.add('text-yellow-400');
                prevX = 0; prevY = 0;
                return;
            }

            if (mode === 'DRAW' || mode === 'ERASE') {
                
                const thickness = mode === 'DRAW' ? DRAW_THICKNESS : ERASER_THICKNESS;
                const color = mode === 'DRAW' ? `rgb(${drawColor})` : 'rgb(0, 0, 0)'; 
                const globalCompositeOperation = mode === 'DRAW' ? 'source-over' : 'destination-out'; 

                statusElement.textContent = mode === 'DRAW' ? `DESENHANDO (${currentTool})` : 'APAGANDO (Borracha)';
                statusElement.classList.remove('text-yellow-400', 'text-white');
                statusElement.classList.add(mode === 'DRAW' ? 'text-green-400' : 'text-red-400');
                
                if (prevX === 0 && prevY === 0) {
                    // Come√ßa um novo tra√ßo
                    prevX = currentX;
                    prevY = currentY;
                } else {
                    // Desenha o tra√ßo
                    ctx.beginPath();
                    ctx.globalCompositeOperation = globalCompositeOperation;
                    ctx.moveTo(prevX, prevY);
                    ctx.lineTo(currentX, currentY);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = thickness;
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    // Atualiza a posi√ß√£o
                    prevX = currentX;
                    prevY = currentY;
                }

            } else {
                // Modo IDLE
                statusElement.textContent = 'INATIVO (Aguardando Gesto)';
                statusElement.classList.remove('text-red-400', 'text-green-400', 'text-yellow-400');
                statusElement.classList.add('text-white');
                prevX = 0; prevY = 0; // Reseta o cursor
            }
        }

        // --- 5. Fun√ß√µes de Controle ---
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function changeColor(colorRgb, toolName, event) {
            drawColor = colorRgb;
            currentTool = toolName;
            
            // Remove o destaque de todos os bot√µes de cor
            document.querySelectorAll('#controls button').forEach(btn => btn.classList.remove('ring-4', 'ring-offset-2', 'ring-indigo-400', 'ring-offset-gray-900'));
            
            // Adiciona destaque ao bot√£o clicado, se n√£o for o bot√£o Limpar
            if (event && event.target.textContent !== 'Limpar') {
                event.target.classList.add('ring-4', 'ring-offset-2', 'ring-indigo-400', 'ring-offset-gray-900');
            }
            
            // Atualiza o feedback visual
            statusElement.textContent = `Cor alterada para ${toolName}!`;
            statusElement.classList.add('text-green-400');
        }

        // --- 6. Inicializa√ß√£o do MediaPipe ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // --- 7. Inicializa√ß√£o da C√¢mera (Chamada pelo Bot√£o) ---
        videoElement = document.createElement('video');
        const outputCanvasContainer = document.querySelector('.canvas-container');

        function startVirtualPen() {
            // Desabilita o bot√£o para evitar cliques m√∫ltiplos
            document.getElementById('start-btn').disabled = true;
            document.getElementById('start-btn').textContent = 'Solicitando C√¢mera...';
            
            // Cria a inst√¢ncia da c√¢mera MediaPipe
            camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                // Define o tamanho da captura
                width: 320, 
                height: 240
            });

            // Garante que os canvas tenham o tamanho correto ap√≥s a inicializa√ß√£o da c√¢mera
            videoElement.addEventListener('loadedmetadata', () => {
                // Define o tamanho de ambos os canvas
                outputCanvas.width = 320;
                outputCanvas.height = 240;
                initDrawingCanvas();
                camera.start();
                
                // Oculta o bot√£o e atualiza o status
                document.getElementById('start-btn').style.display = 'none'; 
                statusElement.textContent = 'C√¢mera Iniciada! Aguardando Gesto.';
            });
            
            // Tenta iniciar a c√¢mera (solicita permiss√£o)
            camera.start().catch(error => {
                console.error("Erro ao iniciar a c√¢mera:", error);
                document.getElementById('start-btn').disabled = false;
                document.getElementById('start-btn').textContent = '‚ùå Erro de Permiss√£o. Tente Novamente.';
                statusElement.textContent = 'ERRO: Permiss√£o de c√¢mera negada ou dispositivo n√£o encontrado.';
                statusElement.classList.add('text-red-400');
            });
            
        }

        // Inicializa o canvas de desenho assim que a p√°gina carrega, mas n√£o a c√¢mera
        initDrawingCanvas();
    </script>
</body>
</html>
